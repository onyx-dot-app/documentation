---
title: "Actions"
description: "Guide for developing custom actions in Onyx"
icon: "play"
---

# Actions

Actions in Onyx are custom tools that extend the capabilities of agents and provide integration with external services. This guide covers how to develop, test, and contribute new actions.

## What are Actions?

Actions are functions that agents can call to perform specific tasks like:
- Creating tickets in issue trackers (Jira, Linear, etc.)
- Sending emails or notifications
- Making API calls to external services
- Performing calculations or data transformations
- Interacting with databases or file systems

## Action Architecture

Actions in Onyx follow a specific structure:

```python
from onyx.tools.models import ToolCallFinalResult
from onyx.tools.tool import Tool

class MyCustomTool(Tool):
    @property
    def name(self) -> str:
        return "my_custom_tool"
    
    @property 
    def description(self) -> str:
        return "Description of what this tool does"
    
    @property
    def display_name(self) -> str:
        return "My Custom Tool"
    
    def tool_definition(self) -> dict:
        return {
            "type": "function",
            "function": {
                "name": self.name,
                "description": self.description,
                "parameters": {
                    "type": "object",
                    "properties": {
                        "param1": {
                            "type": "string",
                            "description": "Description of parameter 1"
                        },
                        "param2": {
                            "type": "integer", 
                            "description": "Description of parameter 2"
                        }
                    },
                    "required": ["param1"]
                }
            }
        }
    
    def run(self, **kwargs) -> ToolCallFinalResult:
        # Implementation goes here
        param1 = kwargs.get("param1")
        param2 = kwargs.get("param2", 0)
        
        try:
            # Perform the action
            result = self._perform_action(param1, param2)
            
            return ToolCallFinalResult(
                tool_name=self.name,
                tool_result=result,
                tool_message_content=f"Successfully executed action with result: {result}"
            )
        except Exception as e:
            return ToolCallFinalResult(
                tool_name=self.name,
                tool_result=None,
                tool_message_content=f"Error executing action: {str(e)}"
            )
    
    def _perform_action(self, param1: str, param2: int) -> str:
        # Your custom logic here
        return f"Processed {param1} with value {param2}"
```

## Creating a New Action

### 1. Define the Action Class

Create a new file in `backend/onyx/tools/custom/` following the pattern above.

### 2. Register the Action

Add your action to the tool registry in `backend/onyx/tools/factory.py`:

```python
from onyx.tools.custom.my_custom_tool import MyCustomTool

# Add to the TOOL_CLASSES dictionary
TOOL_CLASSES = {
    # ... existing tools
    "my_custom_tool": MyCustomTool,
}
```

### 3. Add Configuration (if needed)

If your action requires configuration (API keys, URLs, etc.), add them to the tool configuration:

```python
class MyCustomTool(Tool):
    def __init__(self, api_key: str, base_url: str = "https://api.example.com"):
        self.api_key = api_key
        self.base_url = base_url
    
    # ... rest of implementation
```

### 4. Handle Authentication

For actions that require authentication:

```python
def run(self, **kwargs) -> ToolCallFinalResult:
    if not self.api_key:
        return ToolCallFinalResult(
            tool_name=self.name,
            tool_result=None,
            tool_message_content="API key not configured"
        )
    
    # Continue with authenticated request
```

## Testing Actions

### Unit Tests

Create tests in `backend/tests/unit/tools/test_my_custom_tool.py`:

```python
import pytest
from onyx.tools.custom.my_custom_tool import MyCustomTool

class TestMyCustomTool:
    def test_tool_definition(self):
        tool = MyCustomTool()
        definition = tool.tool_definition()
        
        assert definition["function"]["name"] == "my_custom_tool"
        assert "param1" in definition["function"]["parameters"]["properties"]
    
    def test_successful_execution(self):
        tool = MyCustomTool()
        result = tool.run(param1="test", param2=42)
        
        assert result.tool_name == "my_custom_tool"
        assert "test" in result.tool_message_content
    
    def test_error_handling(self):
        tool = MyCustomTool()
        result = tool.run()  # Missing required parameter
        
        assert "Error" in result.tool_message_content
```

### Integration Tests

Test your action with real API calls (using test environments):

```python
@pytest.mark.integration
def test_real_api_call():
    tool = MyCustomTool(api_key="test_key")
    result = tool.run(param1="integration_test")
    
    # Verify the action actually worked
    assert result.tool_result is not None
```

## Action Best Practices

### Error Handling

Always handle errors gracefully:

```python
def run(self, **kwargs) -> ToolCallFinalResult:
    try:
        # Your action logic
        result = self._perform_action(**kwargs)
        return ToolCallFinalResult(
            tool_name=self.name,
            tool_result=result,
            tool_message_content=f"Success: {result}"
        )
    except ValueError as e:
        return ToolCallFinalResult(
            tool_name=self.name,
            tool_result=None,
            tool_message_content=f"Invalid input: {str(e)}"
        )
    except Exception as e:
        return ToolCallFinalResult(
            tool_name=self.name,
            tool_result=None,
            tool_message_content=f"Unexpected error: {str(e)}"
        )
```

### Parameter Validation

Validate input parameters:

```python
def run(self, **kwargs) -> ToolCallFinalResult:
    required_params = ["param1"]
    missing_params = [p for p in required_params if p not in kwargs]
    
    if missing_params:
        return ToolCallFinalResult(
            tool_name=self.name,
            tool_result=None,
            tool_message_content=f"Missing required parameters: {missing_params}"
        )
    
    # Continue with validated parameters
```

### Logging

Add appropriate logging:

```python
import logging

logger = logging.getLogger(__name__)

def run(self, **kwargs) -> ToolCallFinalResult:
    logger.info(f"Executing {self.name} with params: {kwargs}")
    
    try:
        result = self._perform_action(**kwargs)
        logger.info(f"Successfully executed {self.name}")
        return ToolCallFinalResult(...)
    except Exception as e:
        logger.error(f"Error in {self.name}: {str(e)}")
        return ToolCallFinalResult(...)
```

## Example: Jira Ticket Creation Action

Here's a complete example of a Jira ticket creation action:

```python
import requests
from onyx.tools.models import ToolCallFinalResult
from onyx.tools.tool import Tool

class JiraCreateTicketTool(Tool):
    def __init__(self, jira_url: str, username: str, api_token: str):
        self.jira_url = jira_url.rstrip('/')
        self.username = username
        self.api_token = api_token
    
    @property
    def name(self) -> str:
        return "jira_create_ticket"
    
    @property
    def description(self) -> str:
        return "Create a new ticket in Jira with the specified details"
    
    @property
    def display_name(self) -> str:
        return "Jira Create Ticket"
    
    def tool_definition(self) -> dict:
        return {
            "type": "function",
            "function": {
                "name": self.name,
                "description": self.description,
                "parameters": {
                    "type": "object",
                    "properties": {
                        "project_key": {
                            "type": "string",
                            "description": "The Jira project key (e.g., 'PROJ')"
                        },
                        "summary": {
                            "type": "string",
                            "description": "Brief summary of the issue"
                        },
                        "description": {
                            "type": "string",
                            "description": "Detailed description of the issue"
                        },
                        "issue_type": {
                            "type": "string",
                            "description": "Type of issue (Bug, Task, Story, etc.)",
                            "default": "Task"
                        },
                        "priority": {
                            "type": "string",
                            "description": "Priority level (Highest, High, Medium, Low, Lowest)",
                            "default": "Medium"
                        }
                    },
                    "required": ["project_key", "summary", "description"]
                }
            }
        }
    
    def run(self, **kwargs) -> ToolCallFinalResult:
        project_key = kwargs.get("project_key")
        summary = kwargs.get("summary")
        description = kwargs.get("description")
        issue_type = kwargs.get("issue_type", "Task")
        priority = kwargs.get("priority", "Medium")
        
        if not all([project_key, summary, description]):
            return ToolCallFinalResult(
                tool_name=self.name,
                tool_result=None,
                tool_message_content="Missing required parameters: project_key, summary, or description"
            )
        
        try:
            # Create the Jira ticket
            ticket_data = {
                "fields": {
                    "project": {"key": project_key},
                    "summary": summary,
                    "description": description,
                    "issuetype": {"name": issue_type},
                    "priority": {"name": priority}
                }
            }
            
            response = requests.post(
                f"{self.jira_url}/rest/api/2/issue",
                json=ticket_data,
                auth=(self.username, self.api_token),
                headers={"Content-Type": "application/json"}
            )
            
            if response.status_code == 201:
                ticket_data = response.json()
                ticket_key = ticket_data["key"]
                ticket_url = f"{self.jira_url}/browse/{ticket_key}"
                
                return ToolCallFinalResult(
                    tool_name=self.name,
                    tool_result={
                        "ticket_key": ticket_key,
                        "ticket_url": ticket_url
                    },
                    tool_message_content=f"Successfully created Jira ticket {ticket_key}: {ticket_url}"
                )
            else:
                return ToolCallFinalResult(
                    tool_name=self.name,
                    tool_result=None,
                    tool_message_content=f"Failed to create Jira ticket: {response.status_code} - {response.text}"
                )
                
        except Exception as e:
            return ToolCallFinalResult(
                tool_name=self.name,
                tool_result=None,
                tool_message_content=f"Error creating Jira ticket: {str(e)}"
            )
```

## Contributing Your Action

### 1. Create a Pull Request

1. Fork the repository
2. Create a feature branch: `git checkout -b feature/my-custom-action`
3. Add your action files
4. Add tests
5. Update documentation
6. Create a pull request

### 2. Documentation

Include documentation for your action:

- Add a docstring to your action class
- Include usage examples
- Document any configuration requirements
- Add to the actions documentation

### 3. Review Process

Your action will be reviewed for:

- Code quality and adherence to standards
- Security considerations
- Test coverage
- Documentation completeness
- Usefulness to the community

## Advanced Topics

### Async Actions

For long-running operations, consider making your action async:

```python
import asyncio
from onyx.tools.models import ToolCallFinalResult
from onyx.tools.tool import Tool

class AsyncTool(Tool):
    async def run_async(self, **kwargs) -> ToolCallFinalResult:
        # Async implementation
        result = await self._async_operation(**kwargs)
        return ToolCallFinalResult(...)
```

### Streaming Results

For actions that produce streaming output:

```python
def run_streaming(self, **kwargs) -> Iterator[str]:
    for chunk in self._streaming_operation(**kwargs):
        yield chunk
```

### Configuration Management

For complex configuration needs:

```python
from onyx.configs.app_configs import CUSTOM_TOOL_CONFIG

class ConfigurableTool(Tool):
    def __init__(self):
        self.config = CUSTOM_TOOL_CONFIG.get(self.name, {})
        self.api_key = self.config.get("api_key")
        self.base_url = self.config.get("base_url")
```

## Getting Help

- Check existing actions in `backend/onyx/tools/` for examples
- Join our [Slack community](https://join.slack.com/t/onyx-dot-app/shared_invite/zt-34lu4m7xg-TsKGO6h8PDvR5W27zTdyhA) for help
- Open an issue on GitHub for bugs or feature requests
- Review the [API documentation](/api_reference/actions/overview) for more details 